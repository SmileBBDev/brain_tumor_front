# GCP Docker 배포 워크플로우

## 프로젝트 구조 요약

```
brain_tumor_dev/
├── brain_tumor_back/     # Django 백엔드 (Daphne ASGI)
│   ├── Dockerfile
│   ├── config/
│   │   ├── settings.py
│   │   ├── dev.py
│   │   └── prod.py
│   └── apps/
│       ├── accounts/     # 사용자 인증
│       ├── ocs/          # 주문통신시스템
│       ├── menus/        # 메뉴 관리
│       └── ...
│
├── brain_tumor_front/    # React + Vite 프론트엔드
│   ├── package.json
│   ├── vite.config.ts
│   └── src/
│
├── modAI/                # FastAPI + Celery (AI 모델 서비스)
│   ├── Dockerfile
│   └── requirements.txt
│
└── docker/
    ├── docker-compose.yml           # 기본 인프라 (Orthanc, Redis)
    ├── docker-compose.django.yml    # Django + MySQL
    └── docker-compose.fastapi.yml   # FastAPI + Celery (GPU/CPU)
```

| 서비스 | 기술 스택 | 포트 | 설명 |
|--------|----------|------|------|
| Django | Daphne (ASGI) + Django Channels | 8000 | 메인 백엔드 API, WebSocket |
| FastAPI | Uvicorn + Celery | 9000 | AI 모델 추론 서비스 |
| Frontend | React 19 + Vite + MUI | 80/443 | SPA 프론트엔드 |
| Orthanc | DICOM/PACS | 8042, 4242 | 의료영상 서버 |
| Redis | Cache/Broker | 6379 | Django 캐시 + Celery 브로커 |
| MySQL | Database | 3306 | Django 데이터베이스 |

---

## 배포 아키텍처

```
┌─────────────────────────────────────────────────────────────────┐
│                        Internet                                  │
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Cloudflare (DNS + CDN)                        │
│  - SSL/TLS 종료                                                  │
│  - DDoS 방어                                                     │
│  - 캐싱                                                          │
└───────────────────────────┬─────────────────────────────────────┘
                            │ HTTPS
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                   GCP VM #1 (Main Server)                        │
├─────────────────────────────────────────────────────────────────┤
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                 Nginx (VM에 직접 설치)                      │  │
│  │  - Reverse Proxy                                           │  │
│  │  - Static Files 서빙 (Frontend)                            │  │
│  └─────────┬──────────────┬─────────────────────────────────┘  │
│            │              │                                      │
│       /static        /api, /ws                                   │
│       /assets                                                    │
│            │              │                                      │
│            ▼              ▼                                      │
│  ┌──────────────┐  ┌───────────┐                                │
│  │   Frontend   │  │  Django   │──────────────────┐             │
│  │  (Static)    │  │  :8000    │                  │             │
│  │  /var/www/   │  │  Docker   │                  │             │
│  └──────────────┘  └─────┬─────┘                  │             │
│                          │                        │              │
│                    ┌─────┴─────┐  ┌───────────┐   │             │
│                    │   MySQL   │  │   Redis   │   │             │
│                    │  :3306    │  │  :6379    │   │             │
│                    │  Docker   │  │  Docker   │   │             │
│                    └───────────┘  └───────────┘   │             │
│                                                   │              │
│                    ┌───────────┐                  │             │
│                    │  Orthanc  │                  │             │
│                    │  :8042    │                  │             │
│                    │  Docker   │                  │             │
│                    └───────────┘                  │             │
└───────────────────────────────────────────────────┼─────────────┘
                                                    │
                                          GCP 내부 네트워크
                                          (10.128.0.x:9000)
                                                    │
┌───────────────────────────────────────────────────┼─────────────┐
│                   GCP VM #2 (GPU Server)          │             │
├───────────────────────────────────────────────────┼─────────────┤
│                                                   ▼              │
│                                          ┌───────────┐          │
│                                          │  FastAPI  │          │
│                                          │  :9000    │          │
│                                          │  Docker   │          │
│                                          │  + Celery │          │
│                                          └─────┬─────┘          │
│                                                │                 │
│                                          ┌─────┴─────┐          │
│                                          │   Redis   │          │
│                                          │  :6379    │          │
│                                          │  Docker   │          │
│                                          └───────────┘          │
│                                                                  │
│  ⚡ NVIDIA T4 GPU                                                │
└─────────────────────────────────────────────────────────────────┘
```

---

## 배포 단계 요약

| 단계 | 작업 | 설명 |
|------|------|------|
| **Phase 1** | **Main VM 인프라 준비** | |
| Step 1 | GCP Main VM 생성 | VM 인스턴스 + 방화벽 설정 |
| Step 2 | VM 초기 설정 | 시스템 업데이트 + 필수 패키지 |
| Step 3 | Docker 설치 | Docker + Compose + 자동 시작 |
| **Phase 2** | **GPU VM 인프라 준비** | |
| Step 4 | GCP GPU VM 생성 | GPU VM 인스턴스 + 방화벽 설정 |
| Step 5 | GPU VM 초기 설정 | NVIDIA 드라이버 + Docker 설치 |
| Step 6 | FastAPI 배포 | FastAPI + Celery 컨테이너 실행 |
| **Phase 3** | **Main VM 애플리케이션 배포** | |
| Step 7 | 프로젝트 업로드 | Git clone 또는 SCP |
| Step 8 | 환경변수 설정 | .env 파일 생성 (FastAPI 내부 IP 포함) |
| Step 9 | Docker 컨테이너 실행 | Django + MySQL + Redis + Orthanc 시작 |
| Step 10 | 내부 테스트 | localhost + FastAPI 연결 확인 |
| **Phase 4** | **웹 서버 설정** | |
| Step 11 | Nginx 설정 | Reverse Proxy + 자동 시작 |
| Step 12 | Frontend 배포 | 빌드 + Nginx 디렉토리 복사 |
| Step 13 | 내부 최종 테스트 | curl로 전체 경로 확인 |
| **Phase 5** | **외부 공개** | |
| Step 14 | Cloudflare 설정 | DNS + SSL/TLS |
| Step 15 | 외부 접속 테스트 | 브라우저로 최종 확인 |

---

# Phase 1: Main VM 인프라 준비

## Step 1: GCP Main VM 생성

### 1.1 Main VM 스펙 권장

| 항목 | 최소 사양 | 권장 사양 |
|------|----------|----------|
| Machine Type | e2-medium (2 vCPU, 4GB) | e2-standard-4 (4 vCPU, 16GB) |
| Boot Disk | 30GB SSD | 50GB+ SSD |
| OS | Ubuntu 22.04 LTS | Ubuntu 22.04 LTS |
| Region | asia-northeast3 (서울) | asia-northeast3 |

### 1.2 방화벽 규칙 (Main VM)

GCP Console → VPC Network → Firewall → Create Firewall Rule

| 규칙명 | 방향 | 대상 | 포트 | 소스 |
|--------|------|------|------|------|
| allow-http | Ingress | All instances | tcp:80 | 0.0.0.0/0 |
| allow-https | Ingress | All instances | tcp:443 | 0.0.0.0/0 |

> **주의**: 8000, 3306, 6379 포트는 외부에 열지 않음 (내부 통신만)

---

## Step 2: VM 초기 설정

SSH 접속 후 실행:

```bash
# 시스템 업데이트
sudo apt update && sudo apt upgrade -y

# 필수 패키지 설치
sudo apt install -y \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg \
    lsb-release \
    git
```

---

## Step 3: Docker 설치

```bash
# Docker GPG 키 추가
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

# Docker 리포지토리 추가
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

# Docker 설치
sudo apt update
sudo apt install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin

# 현재 사용자를 docker 그룹에 추가 (sudo 없이 docker 사용)
sudo usermod -aG docker $USER

# 그룹 변경 적용 (재로그인 또는)
newgrp docker

# 설치 확인
docker --version
docker compose version

# ⭐ Docker 부팅 시 자동 시작 설정
sudo systemctl enable docker
sudo systemctl enable containerd
```

---

# Phase 2: GPU VM 인프라 준비

## Step 4: GCP GPU VM 생성

### 4.1 GPU VM 스펙

| 항목 | 권장 사양 |
|------|----------|
| Machine Type | n1-standard-4 (4 vCPU, 15GB) |
| GPU | NVIDIA T4 x 1 |
| Boot Disk | 50GB+ SSD |
| OS | Ubuntu 22.04 LTS |
| Region | asia-northeast3 (서울) |

> **참고**: GPU VM은 일반 VM보다 비용이 높으므로, 필요 시에만 실행하거나 Preemptible VM 사용 고려

### 4.2 방화벽 규칙 (GPU VM)

| 규칙명 | 방향 | 대상 | 포트 | 소스 |
|--------|------|------|------|------|
| allow-fastapi-internal | Ingress | gpu-vm 태그 | tcp:9000 | 10.128.0.0/24 (VPC 내부) |

> **중요**: FastAPI 9000 포트는 **Main VM 내부 IP에서만** 접근 가능하도록 설정

---

## Step 5: GPU VM 초기 설정

### 5.1 시스템 업데이트 및 필수 패키지

```bash
# SSH 접속 후 실행
sudo apt update && sudo apt upgrade -y

sudo apt install -y \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg \
    lsb-release \
    git
```

### 5.2 NVIDIA 드라이버 설치

```bash
# NVIDIA 드라이버 설치 (Ubuntu 22.04)
sudo apt install -y linux-headers-$(uname -r)

# NVIDIA 드라이버 저장소 추가
distribution=$(. /etc/os-release;echo $ID$VERSION_ID)
curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -
curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list

# 드라이버 설치
sudo apt update
sudo apt install -y nvidia-driver-535

# 재부팅 필요
sudo reboot
```

### 5.3 드라이버 설치 확인

```bash
# 재부팅 후 확인
nvidia-smi

# 예상 출력:
# +-----------------------------------------------------------------------------+
# | NVIDIA-SMI 535.xx.xx    Driver Version: 535.xx.xx    CUDA Version: 12.x    |
# |-------------------------------+----------------------+----------------------+
# | GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
# | Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
# |===============================+======================+======================|
# |   0  Tesla T4            Off  | 00000000:00:04.0 Off |                    0 |
# | N/A   40C    P8     9W /  70W |      0MiB / 15360MiB |      0%      Default |
# +-------------------------------+----------------------+----------------------+
```

### 5.4 Docker + NVIDIA Container Toolkit 설치

```bash
# Docker 설치
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

sudo apt update
sudo apt install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin

# NVIDIA Container Toolkit 설치
sudo apt install -y nvidia-container-toolkit

# Docker 데몬 재시작
sudo systemctl restart docker

# Docker에서 GPU 사용 확인
sudo docker run --rm --gpus all nvidia/cuda:12.0-base nvidia-smi

# 현재 사용자를 docker 그룹에 추가
sudo usermod -aG docker $USER
newgrp docker

# Docker 부팅 시 자동 시작
sudo systemctl enable docker
sudo systemctl enable containerd
```

---

## Step 6: FastAPI 배포 (GPU VM)

### 6.1 프로젝트 업로드

```bash
mkdir -p ~/app
cd ~/app
git clone <your-repo-url> brain_tumor_dev
```

### 6.2 환경변수 설정

```bash
cd ~/app/brain_tumor_dev/docker
nano .env
```

```env
# ===========================================
# FastAPI / AI Service (GPU VM)
# ===========================================
USE_GPU=true
MAIN_VM_IP=10.128.0.x  # Main VM 내부 IP (Django에서 콜백 받을 때 사용)

# Redis (GPU VM 로컬)
REDIS_URL=redis://redis:6379/0
```

### 6.3 FastAPI 컨테이너 실행

```bash
cd ~/app/brain_tumor_dev/docker

# GPU 버전으로 실행
USE_GPU=true docker compose -f docker-compose.fastapi.yml up -d --build

# 실행 상태 확인
docker compose -f docker-compose.fastapi.yml ps

# 로그 확인
docker compose -f docker-compose.fastapi.yml logs -f
```

### 6.4 GPU VM 내부 테스트

```bash
# FastAPI 헬스체크
curl http://localhost:9000/health

# GPU 사용 확인
docker exec -it nn-fastapi nvidia-smi

# GPU VM 내부 IP 확인 (Main VM에서 사용)
hostname -I
# 예: 10.128.0.x
```

> **⚠️ GPU VM 내부 IP를 기록해두세요!** Main VM의 .env 파일에 설정해야 합니다.

---

# Phase 3: Main VM 애플리케이션 배포

## Step 7: 프로젝트 업로드 (Main VM)

### 방법 A: Git Clone (권장)

```bash
mkdir -p ~/app
cd ~/app
git clone <your-repo-url> brain_tumor_dev
```

### 방법 B: SCP로 파일 전송

```bash
# 로컬에서 실행
scp -r ./brain_tumor_dev user@VM_EXTERNAL_IP:~/app/
```

---

## Step 8: 환경변수 설정 (Main VM)

```bash
cd ~/app/brain_tumor_dev/docker

# .env 파일 생성
nano .env
```

```env
# ===========================================
# Django Settings
# ===========================================
DJANGO_DEBUG=False
DJANGO_SECRET_KEY=your-very-long-and-random-secret-key-change-this-in-production
DJANGO_ALLOWED_HOSTS=your-domain.com,www.your-domain.com,VM_EXTERNAL_IP

# ===========================================
# Database (MySQL)
# ===========================================
DJANGO_DB_ROOT_PASS=StrongRootPassword123!
DJANGO_DB_NAME=brain_tumor
DJANGO_DB_USER=brain_user
DJANGO_DB_PASS=StrongDBPassword456!

# ===========================================
# FastAPI / AI Service (GPU VM 내부 IP)
# ===========================================
FASTAPI_URL=http://10.128.0.x:9000  # ⚠️ GPU VM 내부 IP로 변경!

# ===========================================
# Orthanc (DICOM/PACS)
# ===========================================
ORTHANC_USER=orthanc
ORTHANC_PASSWORD=StrongOrthancPassword789!

# ===========================================
# Email (Optional)
# ===========================================
EMAIL_HOST_USER=your-email@gmail.com
EMAIL_HOST_PASSWORD=your-app-password
```

```bash
# 보안을 위해 권한 설정
chmod 600 .env
```

> **⚠️ 중요**: `FASTAPI_URL`에 GPU VM의 내부 IP (Step 6.4에서 확인한 값)를 입력하세요!

---

## Step 9: Docker 컨테이너 실행 (Main VM)

### 9.1 백그라운드 실행 방법

| 방법 | 명령어 | 설명 |
|------|--------|------|
| **docker -d (권장)** | `docker compose up -d` | Docker 자체 detach 모드 |
| nohup | `nohup command > log 2>&1 &` | 터미널 종료 후에도 유지 |
| screen | `screen -S docker` | 가상 터미널 세션 |
| tmux | `tmux new -s docker` | 터미널 멀티플렉서 |

> **결론**: `docker compose up -d`의 `-d` 옵션이 가장 적합
> `restart: always` 설정과 함께 사용하면 VM 재시작 시에도 자동 실행됨

### 9.2 컨테이너 실행

```bash
cd ~/app/brain_tumor_dev/docker

# Django + MySQL + Redis + Orthanc 실행 (FastAPI 제외)
docker compose -f docker-compose.django.yml up -d --build

# 실행 상태 확인
docker compose -f docker-compose.django.yml ps

# 로그 확인 (실시간)
docker compose -f docker-compose.django.yml logs -f
```

> **참고**: FastAPI는 GPU VM에서 별도로 실행됩니다 (Step 6 참조)

---

## Step 10: 내부 테스트 (Main VM)

Nginx 설정 전에 Docker 컨테이너와 GPU VM 연결이 정상 동작하는지 확인합니다.

```bash
# 컨테이너 상태 확인
docker compose -f docker-compose.django.yml ps

# 예상 출력:
# NAME          STATUS                   PORTS
# nn-django     Up (healthy)             0.0.0.0:8000->8000/tcp
# nn-django-db  Up (healthy)             0.0.0.0:3306->3306/tcp
# nn-orthanc    Up (healthy)             0.0.0.0:8042->8042/tcp
# nn-redis      Up (healthy)             0.0.0.0:6379->6379/tcp

# Django 헬스체크
curl http://localhost:8000/health/

# Redis 연결 확인
docker exec -it nn-redis redis-cli ping
# 응답: PONG

# ⭐ GPU VM FastAPI 연결 테스트 (내부 IP 사용)
curl http://10.128.0.x:9000/health  # GPU VM 내부 IP로 변경
# 응답: {"status": "healthy"}
```

> **⚠️ 이 단계에서 문제가 있으면 다음 단계로 진행하지 마세요!**
> - Main VM 로그: `docker compose logs -f`
> - GPU VM FastAPI 연결 실패 시: 방화벽 규칙 확인 (Step 4.2)

---

# Phase 4: 웹 서버 설정

## Step 11: Nginx 설정

### 11.1 Nginx 설치

```bash
sudo apt install -y nginx
```

### 11.2 설정 파일 생성

```bash
sudo nano /etc/nginx/sites-available/brain-tumor
```

```nginx
server {
    listen 80;
    server_name your-domain.com www.your-domain.com;

    # 클라이언트 최대 업로드 크기 (DICOM 파일용)
    client_max_body_size 100M;

    # ================================
    # Frontend (React SPA)
    # ================================
    location / {
        root /var/www/html;
        index index.html;
        try_files $uri $uri/ /index.html;

        # 캐싱 설정
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
        }
    }

    # ================================
    # Django API
    # ================================
    location /api/ {
        proxy_pass http://127.0.0.1:8000;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # 타임아웃 설정
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }

    # ================================
    # Django WebSocket (Django Channels)
    # ================================
    location /ws/ {
        proxy_pass http://127.0.0.1:8000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        # WebSocket 타임아웃
        proxy_read_timeout 86400;
    }

    # ================================
    # Orthanc (DICOM Viewer) - 선택사항
    # ================================
    location /orthanc/ {
        proxy_pass http://127.0.0.1:8042/;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # ================================
    # Django Static/Media Files
    # ================================
    location /static/ {
        alias /var/www/static/;
    }

    location /media/ {
        alias /var/www/media/;
    }
}
```

### 11.3 설정 활성화 및 자동 시작

```bash
# 심볼릭 링크 생성
sudo ln -s /etc/nginx/sites-available/brain-tumor /etc/nginx/sites-enabled/

# 기본 설정 제거
sudo rm -f /etc/nginx/sites-enabled/default

# 설정 문법 검사
sudo nginx -t

# Nginx 재시작
sudo systemctl restart nginx

# ⭐ Nginx 부팅 시 자동 시작 설정
sudo systemctl enable nginx
```

### 11.4 Static 디렉토리 준비

```bash
# 디렉토리 생성
sudo mkdir -p /var/www/html /var/www/static /var/www/media

# Django collectstatic 실행 후 복사
docker exec nn-django python manage.py collectstatic --noinput
sudo docker cp nn-django:/app/static/. /var/www/static/

# 권한 설정
sudo chown -R www-data:www-data /var/www
```

---

## Step 12: Frontend 배포

### 방법 A: 로컬에서 빌드 후 전송

```bash
# 로컬에서 실행
cd brain_tumor_front

# 의존성 설치
npm install

# 프로덕션 빌드
npm run build

# VM으로 전송
scp -r dist/* user@VM_EXTERNAL_IP:/tmp/frontend/

# VM에서 실행
sudo cp -r /tmp/frontend/* /var/www/html/
sudo chown -R www-data:www-data /var/www/html
```

### 방법 B: VM에서 직접 빌드

```bash
# Node.js 설치 (VM에서)
curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
sudo apt install -y nodejs

# 빌드
cd ~/app/brain_tumor_dev/brain_tumor_front
npm install
npm run build

# Nginx 디렉토리로 복사
sudo cp -r dist/* /var/www/html/
sudo chown -R www-data:www-data /var/www/html
```

---

## Step 13: 내부 최종 테스트

Cloudflare 연결 전에 VM 내부에서 모든 경로가 동작하는지 확인합니다.

```bash
# Nginx 상태 확인
sudo systemctl status nginx

# Frontend 확인 (HTML 반환되어야 함)
curl -I http://localhost/

# Django API 확인
curl http://localhost/api/

# Django Health 확인
curl http://localhost:8000/health/

# GPU VM FastAPI 연결 확인 (Django 내부에서 호출)
curl http://10.128.0.x:9000/health  # GPU VM 내부 IP

# 포트 사용 현황 확인
sudo ss -tlnp | grep -E '80|8000'
```

> **⚠️ 모든 curl 테스트가 성공해야 다음 단계로 진행하세요!**

---

# Phase 5: 외부 공개

## Step 14: Cloudflare 설정

> **참고**: Cloudflare는 외부 SaaS 서비스이므로 VM 재시작과 관계없이 항상 동작합니다.
> 별도의 자동 시작 설정이 필요 없습니다.

### 14.1 DNS 설정

Cloudflare Dashboard → 도메인 선택 → DNS

| Type | Name | Content | Proxy |
|------|------|---------|-------|
| A | @ | VM_EXTERNAL_IP | Proxied (주황색) |
| A | www | VM_EXTERNAL_IP | Proxied (주황색) |

### 14.2 SSL/TLS 설정

Cloudflare Dashboard → SSL/TLS

1. **Overview** → **Full** 또는 **Full (strict)** 선택
2. **Edge Certificates** → Always Use HTTPS: **On**
3. **Edge Certificates** → Minimum TLS Version: **TLS 1.2**

### 14.3 보안 설정 (선택)

- **Security → Settings** → Security Level: **Medium**
- **Security → Bots** → Bot Fight Mode: **On**
- **Speed → Optimization** → Auto Minify: JS, CSS, HTML 체크

---

## Step 15: 외부 접속 테스트

### 15.1 브라우저 테스트

- Frontend: `https://your-domain.com`
- Django API: `https://your-domain.com/api/`
- Orthanc: `https://your-domain.com/orthanc/` (설정한 경우)

### 15.2 HTTPS 확인

```bash
# SSL 인증서 확인
curl -I https://your-domain.com

# 응답 헤더에서 확인할 것:
# - HTTP/2 200
# - cf-ray: (Cloudflare 경유 확인)
```

---

# 자동 시작 설정 요약

## Main VM

| 구성요소 | 설정 명령어 | 설정 위치 |
|----------|------------|----------|
| Docker 데몬 | `sudo systemctl enable docker` | Step 3 |
| Docker 컨테이너 | `restart: always` (docker-compose.yml) | 이미 설정됨 |
| Nginx | `sudo systemctl enable nginx` | Step 11 |
| Cloudflare | 설정 불필요 (외부 SaaS) | - |

## GPU VM

| 구성요소 | 설정 명령어 | 설정 위치 |
|----------|------------|----------|
| Docker 데몬 | `sudo systemctl enable docker` | Step 5.4 |
| Docker 컨테이너 | `restart: always` (docker-compose.yml) | 이미 설정됨 |

### VM 재시작 시 자동 시작 순서

```
┌─────────────────────────────────────────────────────────────────┐
│                         Main VM                                  │
├─────────────────────────────────────────────────────────────────┤
│  OS 부팅                                                         │
│      ↓                                                           │
│  Docker 데몬 시작 (systemctl enable docker)                      │
│      ↓                                                           │
│  Docker 컨테이너 자동 시작 (restart: always)                     │
│  - Django, MySQL, Redis, Orthanc                                │
│      ↓                                                           │
│  Nginx 시작 (systemctl enable nginx)                            │
│      ↓                                                           │
│  Cloudflare에서 트래픽 수신 (항상 동작)                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                         GPU VM                                   │
├─────────────────────────────────────────────────────────────────┤
│  OS 부팅                                                         │
│      ↓                                                           │
│  NVIDIA 드라이버 로드                                            │
│      ↓                                                           │
│  Docker 데몬 시작 (systemctl enable docker)                      │
│      ↓                                                           │
│  Docker 컨테이너 자동 시작 (restart: always)                     │
│  - FastAPI, Celery, Redis                                       │
│      ↓                                                           │
│  Main VM에서 내부 IP로 연결 대기                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

# 유용한 명령어 모음

## Docker 관리

```bash
# 로그 확인 (실시간)
docker compose -f docker-compose.django.yml logs -f

# 특정 서비스 로그
docker compose -f docker-compose.django.yml logs -f django

# 컨테이너 재시작
docker compose -f docker-compose.django.yml restart django

# 전체 중지
docker compose -f docker-compose.django.yml down

# 볼륨 포함 삭제 (주의: 데이터 삭제됨)
docker compose -f docker-compose.django.yml down -v

# 이미지 재빌드
docker compose -f docker-compose.django.yml up -d --build --force-recreate

# 리소스 정리 (미사용 이미지/컨테이너)
docker system prune -af
```

## 컨테이너 내부 접속

```bash
# Django 컨테이너 접속
docker exec -it nn-django bash

# Django 쉘
docker exec -it nn-django python manage.py shell

# MySQL 접속
docker exec -it nn-django-db mysql -u root -p

# Redis 접속
docker exec -it nn-redis redis-cli
```

## 로그 확인

```bash
# Nginx 에러 로그
sudo tail -f /var/log/nginx/error.log

# Nginx 액세스 로그
sudo tail -f /var/log/nginx/access.log

# 시스템 로그
sudo journalctl -u nginx -f
```

## 포트 확인

```bash
# 사용 중인 포트 확인
sudo netstat -tlnp | grep -E '80|443|8000|9000|3306|6379'

# 또는
sudo ss -tlnp | grep -E '80|443|8000|9000'
```

---

# 주의사항 체크리스트

## 보안

### Main VM
- [ ] `.env` 파일 권한 600 설정
- [ ] `DJANGO_DEBUG=False` 확인
- [ ] `SECRET_KEY` 강력한 값으로 변경
- [ ] 데이터베이스 비밀번호 강력하게 설정
- [ ] GCP 방화벽에서 80, 443만 외부 허용
- [ ] 내부 포트 (8000, 3306, 6379) 외부 노출 안함
- [ ] CORS 설정 확인 (허용된 도메인만)
- [ ] Orthanc 기본 비밀번호 변경

### GPU VM
- [ ] `.env` 파일 권한 600 설정
- [ ] 9000 포트는 Main VM 내부 IP에서만 접근 허용
- [ ] 외부 IP로 FastAPI 직접 접근 불가 확인

## 자동 시작

### Main VM
- [ ] Docker 서비스: `sudo systemctl enable docker` (Step 3)
- [ ] Nginx 서비스: `sudo systemctl enable nginx` (Step 11)
- [ ] Docker 컨테이너: `restart: always` 설정 확인

### GPU VM
- [ ] Docker 서비스: `sudo systemctl enable docker` (Step 5.4)
- [ ] Docker 컨테이너: `restart: always` 설정 확인
- [ ] Cloudflare: 외부 서비스이므로 별도 설정 불필요

## 성능

- [ ] Nginx gzip 압축 활성화
- [ ] 정적 파일 캐싱 설정
- [ ] 데이터베이스 연결 풀 설정

## 백업

- [ ] MySQL 데이터 백업 스크립트 설정
- [ ] Docker 볼륨 백업 계획
- [ ] 중요 설정 파일 백업 (.env, nginx 설정 등)

---

# 문제 해결

## 502 Bad Gateway

```bash
# Django 컨테이너 상태 확인
docker ps | grep django
docker logs nn-django --tail 50

# Nginx upstream 연결 확인
curl -v http://127.0.0.1:8000/health/
```

## WebSocket 연결 실패

```bash
# Django Channels 로그 확인
docker logs nn-django | grep -i websocket

# Nginx WebSocket 설정 확인
grep -A 10 "location /ws/" /etc/nginx/sites-available/brain-tumor
```

## 데이터베이스 연결 오류

```bash
# MySQL 컨테이너 상태
docker logs nn-django-db --tail 50

# Django에서 DB 연결 테스트
docker exec -it nn-django python manage.py dbshell
```

## FastAPI 연결 실패 (Main VM → GPU VM)

```bash
# Main VM에서 실행

# 1. GPU VM 내부 IP로 연결 테스트
curl -v http://10.128.0.x:9000/health

# 2. 연결 실패 시 체크리스트:
# - GPU VM이 실행 중인지 확인
# - GPU VM의 FastAPI 컨테이너가 실행 중인지 확인
# - GCP 방화벽 규칙 확인 (allow-fastapi-internal)
# - 내부 IP가 올바른지 확인

# GPU VM에서 실행
docker ps | grep fastapi
docker logs nn-fastapi --tail 50

# 방화벽 규칙 테스트 (GPU VM에서)
sudo ufw status  # 또는 GCP Console에서 확인
```

## GPU 인식 안됨 (GPU VM)

```bash
# GPU 드라이버 상태 확인
nvidia-smi

# 드라이버 로드 확인
lsmod | grep nvidia

# Docker에서 GPU 사용 가능 여부
docker run --rm --gpus all nvidia/cuda:12.0-base nvidia-smi

# 드라이버 재설치 필요 시
sudo apt install --reinstall nvidia-driver-535
sudo reboot
```

## 디스크 용량 부족

```bash
# 디스크 사용량 확인
df -h

# Docker 정리
docker system prune -af
docker volume prune -f
```
